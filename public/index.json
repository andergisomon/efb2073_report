[{"content":"Team members At the time of taking this course, we are second year third semester Electrical and Electronics Engineering students in Universiti Teknologi PETRONAS.\nVolintine Ander Zechariah Hwong Eddry Haqimy 21001524 21001586 21001460 Aziz Abdul Bagas Kensley Kudang Kennedy 21000360 21001068 Task allocation Software Implementation:\nVolintine Ander - ESP IDF rewrite and data logging Zechariah Hwong - Transmitter coding Eddry Haqimy - Receiver coding Web Report\nAziz Abdul Bagas Kensley Kudang Kennedy ","permalink":"http://localhost:1313/posts/about_us/","summary":"More information on each team member","title":"About the Team"},{"content":"Project Background Our project makes use of ESP-NOW, a wireless communication protocol developed by Espressif for short packet transmission. This versatile protocol enables multiple devices to talk to each other via Wi-Fi with ESP-NOW protocol.\nIn many industrial, commercial, and residential applications, traditional wired communications are still widely used for controlling various systems and devices, mostly to turn ON/OFF certain devices. Our system replaces clunky wires in exchange for modular wireless switches.\nProblem Statement Wired systems quickly become inconvenient when many devices need to be controlled. This scalability issue can be solved using a wireless control system, which we implemented using ESP NOW.\nObjectives To update currently wired switches by wireless switches To enable users to control their devices from multiple location through wireless transmission To use local transmission for private IoT applications/environment Tech stack A brief description of the technologies we used throughout the project.\nNO PART of the Arduino framework was used. Hardware Seeed XIAO ESP32C3 boards (x2) LEDs Switches Buzzer Software frameworks For embedded programming\nESP IoT Development Framework (ESP IDF) Powershell (for data logging) Visual Studio Code + ESP IDF extension IDF Frontend For web report\nHugo (website building) Git (version control) GitHub Pages (static site hosting) Programming/markup languages\nC (everything else) JavaScript, CSS, HTML (website report) ","permalink":"http://localhost:1313/posts/intro/","summary":"Project Background, Problem Statement, Objectives","title":"Introduction"},{"content":"Hardware selection Materials used in this project:\nESP32C3 LEDs Buzzer Note: LEDs and Buzzer are just for demonstration purposes, as we want to demonstrate how our module works, the LEDs and Buzzer may be replaced by any other industrial device or appliance.\nFeatures ESP32C ESP 8266 STM32 with Wi-Fi Module ESP-NOW Protocol Support Native support No native support Typically unsupported Power Efficiency High, supports deep sleep modes Moderate, less efficient Varies, generally less efficient Performance and Features High, RISC-V architecture Moderate, Tensilica Xtensa Varies, depends on configuration Development Ecosystem and Community Support Extensive, strong community Good, less advanced Strong for STM32, complex configuration Cost and Availability Cost-effective Cheaper, fewer features More expensive, complex integration For this project we have chosen to work with the ESP32C3. The ESP32C3 is better suited for wireless switch module due to its native support for the ESP-NOW protocol, improved power efficiency, better performance, and more robust development ecosystem compared to the ESP8266 and STM32 with a Wi-Fi module.\nHardware design Transmitter Receiver The ESP-NOW protocol requires that two ESP32C3, one to act as a transmitter and another as a receiver. Each board was was connected to their out-of-the-box antennae to increase SNR.\nThe transmitter is wired to accept input from 3 switches, each button when pressed would toggle the associated pins on the receiver sides.\nThe receiver is wired to 3 LEDs and when data is received from the transmitter, it would toggle the associated pins either from (HIGH to LOW) or (LOW to HIGH). The 3 LEDS, are just to indicate switching.\n","permalink":"http://localhost:1313/posts/hardware/","summary":"Hardware selection, Harware design","title":"Hardware Development Process"},{"content":"Flowchart Receiver Transmitter Discussion Technical challenges faced 1. No Arduino code requirement Since Arduino itself is a framework that relies on ESP IDF, the technical requirement of a codebase that does not use the Arduino framework is a major obstacle. ESP IDF in comparison is a low-level framework with a level of documentation and support that is orders of magnitude lower than that of Arduino.\n2. Lack of convenient APIs ESP IDF also has a steeper learning curve as it comprises of low-level APIs specific to Espressif SoCs. Many functionalities will need to be written from scratch, compared to Arduino that enjoys an ecosystem of diverse libraries that make it easy to develop for.\n3. Limited Community Support Oftentimes we are the first to implement something in pure ESP IDF. The technical documentation provided by ESP IDF is sometimes scarce, outdated, or available only in Chinese. Example implementations are often irrelevant, uncommented and supplied with no README.\nOvercoming the challenges We worked from afternoon to the early morning multiple times; reading through documentation and ESP IDF source code to debug our code. Since it seemed like an impossible requirement, we initially implemented our project using Arduino, and translated the code into pure ESP IDF once we figured out the base code.\nWeb development Using the Hugo framework, we used JavaScript, HTML, and CSS to develop this web report. Additionally, we opted to use GitHub pages to host this report for free without ads or background trackers which are permanently enabled for those who use Wix\r, Google Sites, Weebly\r, or other free web building sites.\nThe report reader can rest assured that no personal data is secretly used, as this website is a static site built by the team from the ground up. In fact, we used a software development philosophy called \u0026ldquo;build in public\u0026rdquo; (BIP), where anyone can independently audit our website\r.\n","permalink":"http://localhost:1313/posts/development_process/","summary":"Further discussion, technical challenges, and how we had overcome them","title":"Software development process"},{"content":"End product There are no words that best describe our promising project, so let us demonstrate our end product in action in the following video:\nApplications The Module serves as a very flexible attachment to any control systems that require switching. A receiver and transmitter are only required to establish the Intranet system. An example of application of the module would be in a relay circuit as the switch relay as shown below. The receiver would interact with the switch to enable the power of any high-powered system without being connected to the board and potentially frying it.\nOur Multipurpose IoT Automation with RISC-V project can be implemented in endless scenarios, examples of application in the industry for this relay circuit would be::\nPublic Transport - Sexual harassment alarm on trains, toilet lock/unlocking, etc. Home Automation - Lights control, security system, etc. Industrial Application - Machinery control, process monitoring, etc. Health Care - Patient room control, emergency systems, etc. Agriculture - Irrigation control, greenhouse automation, etc. As an example of application of our module, we will demonstrate our module being used in an indoor farming system:\nConclusion Our module is a proof-of-concept implementation of cloudless IoT technology. This paves the road towards Intranet of Things as opposed to Internet of Things. Our system operates independently of third-party vendors (such as AWS, Azure, Clouflare, etc.), ensuring complete vendor independence. The benefits of this approach make it an attractive option for organizations looking for secure IoT solutions, unlike the mainstream approach.\nThe primary advantage of our approach is full data sovereignty, allowing users to maintain full control over information and access.\nOur module is fully air-gapped, as no data is exchanged with external servers. This decreases the attack surface for malicious parties to exploit.\nBusinesses can achieve a higher degree of security and privacy while retaining complete ownership of their data.\nData logging implementation for data storage and system control\nRecommendations Adding sensors and handling analog values Buttons control through an app Transmit text data between boards and print on LCD Integration with virtual assistants such as Amazon Alexa or Google Assistant An easy-to-use drag-and-drop interface for end users ","permalink":"http://localhost:1313/posts/results/","summary":"See our end product in action, conclusion, and future recommendations","title":"Project Outcomes \u0026 Accomplishments"},{"content":"The source code for this web report is available here\r. Source code for the ESP32C3 boards are available here\r.\nTransmitter program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/timers.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_system.h\u0026#34; #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;esp_mac.h\u0026#34; #include \u0026#34;espnow_utils.h\u0026#34; #include \u0026#34;espnow.h\u0026#34; #include \u0026#34;espnow_ctrl.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;espnow_mem.h\u0026#34; // #include \u0026#34;build/config/sdkconfig.h\u0026#34; // Posuango popianai do intellisense nopo, pokinomio\u0026#39; pogulu mamaal /* Include only to shut up intellisense nagging */ #define KOTOS_1 2 // GPIO2, D0 id dulak / on the board #define KOTOS_2 3 // GPIO3, D1 id dulak / on the board #define KOTOS_3 4 // GPIO4, D2 id dulak / on the board int prev1 = 0; int prev2 = 0; int prev3 = 0; int current1 = 0; int current2 = 0; int current3 = 0; uint8_t pagatadan[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // Broadcast mode address static const char *TAG = \u0026#34;sodusuhu\u0026#34;; typedef struct gamit { int buttonstate1; int buttonstate2; int buttonstate3; int buttonstate4; int buttonstate5; int buttonstate6; } gamit; gamit dolinon; // Mamadalin do poiloon id pampos Poniasan / For transfering data to transmitter function static void ponimpuun_wifi() { esp_event_loop_create_default(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(\u0026amp;cfg)); ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM)); ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE)); ESP_ERROR_CHECK(esp_wifi_start()); } // Initialize read pins static void ponimpuun_pomiri(void) { gpio_reset_pin(KOTOS_1); gpio_reset_pin(KOTOS_2); gpio_reset_pin(KOTOS_3); /* Tolu GPIO hiti nopo nga\u0026#39; pinisok / Three of these GPIO are buttons */ gpio_set_direction(KOTOS_1, GPIO_MODE_INPUT); gpio_set_direction(KOTOS_2, GPIO_MODE_INPUT); gpio_set_direction(KOTOS_3, GPIO_MODE_INPUT); } // Function for reading GPIO pipns static void pomiri(void) { current1 = gpio_get_level(KOTOS_1); current2 = gpio_get_level(KOTOS_2); current3 = gpio_get_level(KOTOS_3); if (prev1 == 0 \u0026amp;\u0026amp; current1 == 1) { dolinon.buttonstate1 = 1; } else { dolinon.buttonstate1 = 0; } if (prev2 == 0 \u0026amp;\u0026amp; current2 == 1) { dolinon.buttonstate2 = 1; } else { dolinon.buttonstate2 = 0; } if (prev3 == 0 \u0026amp;\u0026amp; current3 == 1) { dolinon.buttonstate3 = 1; } else { dolinon.buttonstate3 = 0; } } static void poniasan(void *arg) { esp_err_t sinuli = ESP_OK; while (1) { pomiri(); vTaskDelay(50 / portTICK_PERIOD_MS); esp_now_send(pagatadan, (uint8_t *) \u0026amp;dolinon, sizeof(dolinon)); printf(\u0026#34;\\n%i\\n\u0026#34;, sinuli); printf(\u0026#34;Switch 1: %d\u0026#34;, dolinon.buttonstate1); printf(\u0026#34;Switch 2: %d\u0026#34;, dolinon.buttonstate2); printf(\u0026#34;Switch 3: %d\u0026#34;, dolinon.buttonstate3); prev1 = current1; prev2 = current2; prev3 = current3; vTaskDelay(100 / portTICK_PERIOD_MS); } ESP_LOGI(TAG, \u0026#34;Poniasan nakalabus / Transmission exited\u0026#34;); vTaskDelete(NULL); } static void ponimpuun_ponias(void) { xTaskCreate(poniasan, \u0026#34;Popotimpuun ponias / Initialize transmitter\u0026#34;, 4 * 1024, NULL, tskIDLE_PRIORITY + 1, NULL); } void app_main(void) { ponimpuun_pomiri(); espnow_storage_init(); ponimpuun_ponias(); ponimpuun_wifi(); espnow_config_t espnow_config = ESPNOW_INIT_CONFIG_DEFAULT(); espnow_init(\u0026amp;espnow_config); } Receiver program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_system.h\u0026#34; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/timers.h\u0026#34; #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;esp_mac.h\u0026#34; #include \u0026#34;espnow_utils.h\u0026#34; #include \u0026#34;espnow.h\u0026#34; #include \u0026#34;espnow_ctrl.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;espnow_mem.h\u0026#34; #include \u0026lt;sys/time.h\u0026gt; // Montok hiza / for time //#include \u0026#34;build/config/sdkconfig.h\u0026#34; // Posuango popianai do intellisense nopo, pokinomio\u0026#39; pogulu mamaal /* Only to silence intellisense nagging, comment before building */ #define KOTOS_1 2 // GPIO2, D0 id dulak / on board #define KOTOS_2 3 // GPIO3, D1 id dulak / on board #define KOTOS_3 4 // GPIO4, D2 id dulak / on board #define BIRI_1 5 // GPIO5, D3 id dulak / on board #define BIRI_2 6 // GPIO6, D4 id dulak / on board #define BIRI_3 7 // GPIO7, D5 id dulak / on board typedef struct gamit { int buttonstate1; int buttonstate2; int buttonstate3; int buttonstate4; int buttonstate5; int buttonstate6; } gamit; gamit dolinon; // Mamadalin do poiloon id pampos Koromitan / For transferring data to Receiving function static const char *TAG = \u0026#34;sodusuhu\u0026#34;; void set_time(void) { struct timeval now; now.tv_sec = 1722541840; // Seconds since Unix epoch / Kiop tantad tinontok Unix now.tv_usec = 0; settimeofday(\u0026amp;now, NULL); } char* get_time(void) { time_t t = time(NULL); struct tm *tm = localtime(\u0026amp;t); return asctime(tm); } static void ponimpuun_wifi() // WiFi init { esp_event_loop_create_default(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(\u0026amp;cfg)); ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM)); ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE)); ESP_ERROR_CHECK(esp_wifi_start()); } static void ponimpuun_kotos(void) { gpio_reset_pin(KOTOS_1); gpio_reset_pin(KOTOS_2); gpio_reset_pin(KOTOS_3); /* Tolu GPIO hiti nopo nga\u0026#39; pinisok / These three GPIOs are buttons */ gpio_set_direction(KOTOS_1, GPIO_MODE_OUTPUT); gpio_set_direction(KOTOS_2, GPIO_MODE_OUTPUT); gpio_set_direction(KOTOS_3, GPIO_MODE_OUTPUT); /* GPIO pomiri don tikid GPIO pinisok / Reader GPIOs for each GPIO buttons */ gpio_set_direction(BIRI_1, GPIO_MODE_INPUT); gpio_set_direction(BIRI_2, GPIO_MODE_INPUT); gpio_set_direction(BIRI_3, GPIO_MODE_INPUT); gpio_set_level(KOTOS_1, 0); gpio_set_level(KOTOS_2, 0); gpio_set_level(KOTOS_3, 0); } void Koromitan(const uint8_t *pagatadan, const uint8_t *poiloon_mikot, int ninaru) { memcpy(\u0026amp;dolinon, poiloon_mikot, sizeof(dolinon)); if (dolinon.buttonstate1 == 1) { gpio_set_level(KOTOS_1, !gpio_get_level(BIRI_1)); ESP_LOGI(TAG, \u0026#34;Button 1 signal received at: %s\u0026#34;, get_time()); } if (dolinon.buttonstate2 == 1) { gpio_set_level(KOTOS_2, !gpio_get_level(BIRI_2)); ESP_LOGI(TAG, \u0026#34;Button 2 signal received at: %s\u0026#34;, get_time()); } if (dolinon.buttonstate3 == 1) { gpio_set_level(KOTOS_3, !gpio_get_level(BIRI_3)); ESP_LOGI(TAG, \u0026#34;Button 3 signal received at: %s\u0026#34;, get_time()); } } void app_main(void) { for (int i = 0; i \u0026lt; 1; i++) { ponimpuun_kotos(); set_time(); } espnow_storage_init(); ponimpuun_wifi(); espnow_config_t espnow_config = ESPNOW_INIT_CONFIG_DEFAULT(); espnow_init(\u0026amp;espnow_config); ESP_ERROR_CHECK(esp_now_register_recv_cb(Koromitan)); ESP_LOGI(TAG, \u0026#34;Receive callback registered\u0026#34;); } Data logging The logging functionality requires a Powershell instance using the IDF frontend: 1 2 PS cd /path/to/idf/project PS idf.py -p COMX monitor \u0026gt; logfile.txt The log contents can be viewed as such: 1 PS Get-Content .\\logfile.txt ","permalink":"http://localhost:1313/posts/source_code/","summary":"View our code in detail","title":"Source code"}]
[{"content":"Team members At the time of taking this course, we are second year third semester Electrical and Electronics Engineering students in Universiti Teknologi PETRONAS.\nVolintine Ander Zechariah Hwong Eddry Haqimy 21001524 21001586 21001460 Aziz Abdul Bagas Kensley Kudang Kennedy 21000360 21001068 Task allocation Volintine Ander - Writing ESP IDF code, website setup, Git repository setup Zechariah Hwong - Transmitter coding, research Eddry Haqimy - Receiver coding, video editing Aziz Abdul Bagas - Web report writing, video direction Kensley Kudang Kennedy - Electrical wiring, web report writing ","permalink":"http://localhost:1313/posts/about_us/","summary":"More information on each team member","title":"About the team"},{"content":"Project Background Our project makes use of ESP-NOW, a wireless communication protocol developed by Espressif for short packet transmission. This versatile protocol enables multiple devices to talk to each other via Wi-Fi with ESP-NOW protocol.\nIn many industrial, commercial, and residential applications, traditional wired communications are still widely used for controlling various systems and devices, mostly to turn ON/OFF certain devices. Our system replaces clunky wires in exchange for modular wireless switches.\nProblem Statement Wired systems quickly become inconvenient when many devices need to be controlled. This scalability issue can be solved using a wireless control system, which we implemented using ESP-NOW.\nObjectives To update currently wired switches by wireless switches To enable users to control their devices from multiple location through wireless transmission To use local transmission for private IoT applications/environment Tech stack NO PART of the Arduino framework was used. Hardware Seeed XIAO ESP32C3 boards (x2) LEDs Buzzer Switches 12V LED strip (x2) DC submersible water pump Auxiliary hardware\nPortable power bank Software frameworks For embedded programming\nESP IoT Development Framework (ESP IDF) Powershell (for data logging) Visual Studio Code + ESP IDF extension IDF Frontend For web report\nHugo (website building) Git (version control) GitHub Pages (static site hosting) Programming/markup languages\nC (everything else) JavaScript, CSS, HTML (website report) ","permalink":"http://localhost:1313/posts/intro/","summary":"Project background, problem statement, and objectives","title":"Introduction"},{"content":"Hardware selection Materials used in this project:\nESP32C3 LEDs Buzzer Switches LED strips Water pump Note: These peripherals are used in our system for illustration, and they may be replaced by other device/appliance.\nFeatures ESP32C ESP 8266 STM32 with Wi-Fi Module ESP-NOW Protocol Support Native support No native support Typically unsupported Power Efficiency High, supports deep sleep modes Moderate, less efficient Varies, generally less efficient Performance and Features High, RISC-V architecture Moderate, Tensilica Xtensa Varies, depends on configuration Development Ecosystem and Community Support Extensive, strong community Good, less advanced Strong for STM32, complex configuration Cost and Availability Cost-effective Cheaper, fewer features More expensive, complex integration For this project we have chosen to work with the ESP32C3. The ESP32C3 is better suited for wireless switch module due to its native support for the ESP-NOW protocol, improved power efficiency, better performance, and more robust development ecosystem compared to the ESP8266 and STM32 with a Wi-Fi module.\nHardware design Transmitter Receiver The ESP-NOW protocol requires that two ESP32C3, one to act as a transmitter and another as a receiver. Each board was was connected to their out-of-the-box antennae to increase SNR.\nThe transmitter is wired to accept input from 3 switches, each button when pressed would toggle the associated pins on the receiver sides.\nThe receiver is wired to 3 LEDs and when data is received from the transmitter, it would toggle the associated pins either from (HIGH to LOW) or (LOW to HIGH). The 3 LEDS, are just to indicate switching.\nIn the indoor farm application, one of the receiver output pins are wired to a buzzer. All output pins were then wired to the signal side of a relay board.\n","permalink":"http://localhost:1313/posts/hardware/","summary":"Hardware selection and design","title":"Hardware development process"},{"content":"Flowchart Receiver Transmitter Discussion Technical challenges faced 1. No Arduino code requirement Arduino for ESP32 itself is a framework that wraps around\rESP IDF. The technical requirement of an Arduino-free codebase is a major hurdle. ESP IDF in comparison is a low-level framework that interfaces more directly to Espressif hardware.\n2. Lack of convenient APIs ESP IDF also has a steeper learning curve as it comprises of low-level APIs specific to Espressif SoCs. Many functionalities do not have convenient high-level abstractions, compared to Arduino that enjoys an ecosystem of diverse libraries that are easy to use.\n3. Limited Community Support Oftentimes we were the first to implement something in pure ESP IDF. The technical documentation provided by ESP IDF is sometimes scarce, outdated, or available only in Chinese. Example implementations are often irrelevant, uncommented and supplied with no README.\nOvercoming the challenges We worked from afternoon to the early morning multiple times; reading through documentation and ESP IDF source code to debug our code.\nSince it seemed like an impossible requirement, we initially implemented our project using Arduino, and translated the code into pure ESP IDF once we figured out the base code.\nWeb development Using the Hugo\rframework, we used JavaScript, HTML, and CSS to develop this web report. For collaborative coding, we used Git\r, the industry standard for version control.\nAdditionally, we opted to use GitHub Pages to host this report for free without ads or background trackers which are permanently enabled for those who use Wix\r, Google Sites, Weebly\r, or other free web building sites.\nThe report reader can rest assured that no personal data is secretly used, as this website is a static site built by the team from the ground up. In fact, we used a software development philosophy called \u0026ldquo;build in public\u0026rdquo; (BIP), where anyone can independently audit our website\r.\n","permalink":"http://localhost:1313/posts/development_process/","summary":"Further discussion, technical challenges, and how we had overcome them","title":"Software development process"},{"content":"End product Brief explainer Example application of our module: Indoor farm Applications The module serves as a very flexible attachment to any control systems that require switching. A receiver and transmitter are only required to establish the Intranet system.\nAn example of application of the module would be in a relay circuit as the switch relay as shown below. The receiver would interact with the switch to control a high-power system without a direct electrical connection to the controller board.\nOur product can be applied in endless scenarios, examples include:\nPublic transport - Sexual harassment alarm on trains, toilet lock/unlocking, inter-carriage device communication etc. Home automation - Lights control, security system, etc. Industrial application - Machinery control, process monitoring, etc. Healthcare - Patient room control, emergency systems, etc. Agriculture - Irrigation control, greenhouse automation, etc. Conclusion Our module is a proof-of-concept implementation of cloudless IoT technology. This paves the road towards Intranet of Things as opposed to Internet of Things. Our system operates independently of third-party vendors (such as AWS, Azure, Clouflare, etc.), ensuring complete vendor independence.\nThe primary advantage of our approach is full data sovereignty, allowing users to maintain full control over information and access.\nOur module is fully air-gapped, as no data is exchanged with external servers. This decreases the attack surface for malicious parties to exploit.\nBusinesses can achieve a higher degree of security and privacy while retaining complete ownership of their data.\nData logging implementation for data storage and system control\nRecommendations Adding sensors and handling analog values App-based switch control Transmit text data between boards and print on LCD Integration with virtual assistants such as Amazon Alexa or Google Assistant An easy-to-use drag-and-drop interface for end users ","permalink":"http://localhost:1313/posts/results/","summary":"See our end product in action, conclusion, and future recommendations","title":"Project outcomes \u0026 Accomplishments"},{"content":"The source code for this web report is available here\r. Source code for the ESP32C3 boards are available here\r.\nTransmitter program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_system.h\u0026#34; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/timers.h\u0026#34; #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;esp_mac.h\u0026#34; #include \u0026#34;espnow_utils.h\u0026#34; #include \u0026#34;espnow.h\u0026#34; #include \u0026#34;espnow_ctrl.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;espnow_mem.h\u0026#34; // #include \u0026#34;build/config/sdkconfig.h\u0026#34; // Posuango popianai do intellisense nopo, pokinomio\u0026#39; pogulu mamaal /* Include only to shut up intellisense nagging */ #define KOTOS_1 2 // GPIO2, D0 id dulak / on the board #define KOTOS_2 3 // GPIO3, D1 id dulak / on the board #define KOTOS_3 4 // GPIO4, D2 id dulak / on the board int prev1 = 0; int prev2 = 0; int prev3 = 0; int current1 = 0; int current2 = 0; int current3 = 0; uint8_t pagatadan[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // Broadcast mode address static const char *TAG = \u0026#34;sodusuhu\u0026#34;; typedef struct gamit { int buttonstate1; int buttonstate2; int buttonstate3; int buttonstate4; int buttonstate5; int buttonstate6; } gamit; gamit dolinon; // Mamadalin do poiloon id pampos Poniasan / For transfering data to transmitter function static void ponimpuun_wifi() { esp_event_loop_create_default(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(\u0026amp;cfg)); ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM)); ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE)); ESP_ERROR_CHECK(esp_wifi_start()); } // Initialize read pins static void ponimpuun_pomiri(void) { gpio_reset_pin(KOTOS_1); gpio_reset_pin(KOTOS_2); gpio_reset_pin(KOTOS_3); /* Tolu GPIO hiti nopo nga\u0026#39; pinisok / Three of these GPIO are buttons */ gpio_set_direction(KOTOS_1, GPIO_MODE_INPUT); gpio_set_direction(KOTOS_2, GPIO_MODE_INPUT); gpio_set_direction(KOTOS_3, GPIO_MODE_INPUT); } // Function for reading GPIO pipns static void pomiri(void) { current1 = gpio_get_level(KOTOS_1); current2 = gpio_get_level(KOTOS_2); current3 = gpio_get_level(KOTOS_3); if (prev1 == 0 \u0026amp;\u0026amp; current1 == 1) { dolinon.buttonstate1 = 1; } else { dolinon.buttonstate1 = 0; } if (prev2 == 0 \u0026amp;\u0026amp; current2 == 1) { dolinon.buttonstate2 = 1; } else { dolinon.buttonstate2 = 0; } if (prev3 == 0 \u0026amp;\u0026amp; current3 == 1) { dolinon.buttonstate3 = 1; } else { dolinon.buttonstate3 = 0; } } static void poniasan(void *arg) { esp_err_t sinuli = ESP_OK; while (1) { pomiri(); vTaskDelay(50 / portTICK_PERIOD_MS); esp_now_send(pagatadan, (uint8_t *) \u0026amp;dolinon, sizeof(dolinon)); printf(\u0026#34;\\n%i\\n\u0026#34;, sinuli); printf(\u0026#34;Switch 1: %d\u0026#34;, dolinon.buttonstate1); printf(\u0026#34;Switch 2: %d\u0026#34;, dolinon.buttonstate2); printf(\u0026#34;Switch 3: %d\u0026#34;, dolinon.buttonstate3); prev1 = current1; prev2 = current2; prev3 = current3; vTaskDelay(100 / portTICK_PERIOD_MS); } ESP_LOGI(TAG, \u0026#34;Poniasan nakalabus / Transmission exited\u0026#34;); vTaskDelete(NULL); } static void ponimpuun_ponias(void) { xTaskCreate(poniasan, \u0026#34;Popotimpuun ponias / Initialize transmitter\u0026#34;, 4 * 1024, NULL, tskIDLE_PRIORITY + 1, NULL); } void app_main(void) { ponimpuun_pomiri(); espnow_storage_init(); ponimpuun_ponias(); ponimpuun_wifi(); espnow_config_t espnow_config = ESPNOW_INIT_CONFIG_DEFAULT(); espnow_init(\u0026amp;espnow_config); } Receiver program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_system.h\u0026#34; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/timers.h\u0026#34; #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;esp_mac.h\u0026#34; #include \u0026#34;espnow_utils.h\u0026#34; #include \u0026#34;espnow.h\u0026#34; #include \u0026#34;espnow_ctrl.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;espnow_mem.h\u0026#34; #include \u0026lt;sys/time.h\u0026gt; // Montok hiza / for time //#include \u0026#34;build/config/sdkconfig.h\u0026#34; // Posuango popianai do intellisense nopo, pokinomio\u0026#39; pogulu mamaal /* Only to silence intellisense nagging, comment before building */ #define KOTOS_1 2 // GPIO2, D0 id dulak / on board #define KOTOS_2 3 // GPIO3, D1 id dulak / on board #define KOTOS_3 4 // GPIO4, D2 id dulak / on board #define BIRI_1 5 // GPIO5, D3 id dulak / on board #define BIRI_2 6 // GPIO6, D4 id dulak / on board #define BIRI_3 7 // GPIO7, D5 id dulak / on board typedef struct gamit { int buttonstate1; int buttonstate2; int buttonstate3; int buttonstate4; int buttonstate5; int buttonstate6; } gamit; gamit dolinon; // Mamadalin do poiloon id pampos Koromitan / For transferring data to Receiving function static const char *TAG = \u0026#34;sodusuhu\u0026#34;; void set_time(void) { struct timeval now; now.tv_sec = 1722541840; // Seconds since Unix epoch / Kiop tantad tinontok Unix now.tv_usec = 0; settimeofday(\u0026amp;now, NULL); } char* get_time(void) { time_t t = time(NULL); struct tm *tm = localtime(\u0026amp;t); return asctime(tm); } static void ponimpuun_wifi() // WiFi init { esp_event_loop_create_default(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(\u0026amp;cfg)); ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM)); ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE)); ESP_ERROR_CHECK(esp_wifi_start()); } static void ponimpuun_kotos(void) { gpio_reset_pin(KOTOS_1); gpio_reset_pin(KOTOS_2); gpio_reset_pin(KOTOS_3); /* Tolu GPIO hiti nopo nga\u0026#39; pinisok / These three GPIOs are buttons */ gpio_set_direction(KOTOS_1, GPIO_MODE_OUTPUT); gpio_set_direction(KOTOS_2, GPIO_MODE_OUTPUT); gpio_set_direction(KOTOS_3, GPIO_MODE_OUTPUT); /* GPIO pomiri don tikid GPIO pinisok / Reader GPIOs for each GPIO buttons */ gpio_set_direction(BIRI_1, GPIO_MODE_INPUT); gpio_set_direction(BIRI_2, GPIO_MODE_INPUT); gpio_set_direction(BIRI_3, GPIO_MODE_INPUT); gpio_set_level(KOTOS_1, 0); gpio_set_level(KOTOS_2, 0); gpio_set_level(KOTOS_3, 0); } void Koromitan(const uint8_t *pagatadan, const uint8_t *poiloon_mikot, int ninaru) { memcpy(\u0026amp;dolinon, poiloon_mikot, sizeof(dolinon)); if (dolinon.buttonstate1 == 1) { gpio_set_level(KOTOS_1, !gpio_get_level(BIRI_1)); ESP_LOGI(TAG, \u0026#34;Button 1 signal received at: %s\u0026#34;, get_time()); } if (dolinon.buttonstate2 == 1) { gpio_set_level(KOTOS_2, !gpio_get_level(BIRI_2)); ESP_LOGI(TAG, \u0026#34;Button 2 signal received at: %s\u0026#34;, get_time()); } if (dolinon.buttonstate3 == 1) { gpio_set_level(KOTOS_3, !gpio_get_level(BIRI_3)); ESP_LOGI(TAG, \u0026#34;Button 3 signal received at: %s\u0026#34;, get_time()); } } void app_main(void) { for (int i = 0; i \u0026lt; 1; i++) { ponimpuun_kotos(); set_time(); } espnow_storage_init(); ponimpuun_wifi(); espnow_config_t espnow_config = ESPNOW_INIT_CONFIG_DEFAULT(); espnow_init(\u0026amp;espnow_config); ESP_ERROR_CHECK(esp_now_register_recv_cb(Koromitan)); ESP_LOGI(TAG, \u0026#34;Receive callback registered\u0026#34;); } Data logging The logging functionality requires a Powershell instance using the IDF frontend: 1 2 PS cd /path/to/idf/project PS idf.py -p COMX monitor \u0026gt; logfile.txt The log contents can be viewed as such: 1 PS Get-Content .\\logfile.txt ","permalink":"http://localhost:1313/posts/source_code/","summary":"View our code in detail","title":"Source code"}]
[{"content":"Team members We are second year third semester Electrical and Electronics Engineering students in Universiti Teknologi PETRONAS. Currently undergoing Microprocessors \u0026amp; Computer Architecture (EFB2073).\nVolintine Ander Zechariah Hwong Eddry Haqimy 21001524 21001586 21001460 Aziz Abdul Bagas Kensley Kudang Kennedy 21000360 21001068 Task allocation Software Implementatiion:\nVolintine Ander: ESP-NOW research \u0026amp; data logger coding Zechariah Hwong: Transmitter coding Eddry Haqimy: Receiver coding Web-based Report:\nAziz Abdul Bagas Kensley Kudang Kennedy ","permalink":"http://localhost:1313/posts/about_us/","summary":"More information on each team member","title":"About the Team"},{"content":"Project Background Our project makes use of ESP-NOW, a wireless communication protocol developed by Espressif for short packet transmission. This versatile protocol enables multiple devices to talk to each other via Wi-Fi with ESP-NOW protocol.\nIn many industrial, commercial, and residential applications, traditional wired communications are still widely used for controlling various systems and devices, mostly to turn ON/OFF certain devices. Our system replaces clunky wires in exchange for modular wireless switches.\nProblem Statement Wired systems quickly become inconvenient when many devices need to be controlled. This scalability issue can be solved using a wireless control system, which we implemented using ESP NOW.\nObjectives To update currently wired switches by wireless switches To enable users to control their devices from multiple location through wireless transmission To use local transmission for private IoT applications/environment Tech stack A brief description of the technologies we used throughout the project.\nNO PART of the Arduino framework was used. Hardware Seeed XIAO ESP32C3 boards (x2) LEDs Switches Software frameworks For embedded programming\nESP IoT Development Framework (ESP IDF) Powershell (for data logging) Visual Studio Code + ESP IDF extension IDF Frontend For web report\nHugo (website building) Git (version control) GitHub Pages (static site hosting) Programming languages\nC (everything else) JavaScript (website report) ","permalink":"http://localhost:1313/posts/intro/","summary":"Project Background, Problem Statement, Objectives","title":"Introduction"},{"content":"Hardware selection Materials used in this project:\nESP32C3 LEDs Buzzer Note: LEDs and Buzzer are just for demonstration purposes, as we want to demonstrate how our module works, the LEDs and Buzzer may be replaced by any other industrial device or appliance.\nFeatures ESP32C ESP 8266 STM32 with Wi-Fi Module ESP-NOW Protocol Support Native support No native support Typically unsupported Power Efficiency High, supports deep sleep modes Moderate, less efficient Varies, generally less efficient Performance and Features High, RISC-V architecture Moderate, Tensilica Xtensa Varies, depends on configuration Development Ecosystem and Community Support Extensive, strong community Good, less advanced Strong for STM32, complex configuration Cost and Availability Cost-effective Cheaper, fewer features More expensive, complex integration For this project we have chosen to work with the ESP32C3. In summary, the ESP32C3 is better suited for wireless switch module due to its native support for the ESP-NOW protocol, improved power efficiency, better performance, and more robust development ecosystem compared to the ESP8266 and STM32 with a Wi-Fi module, and we already had an ESP32C3 boards in our possessions.\nHardware design Transmitter Receiver The ESP-NOW protocol requires that two ESP32C3, one to act as a transmitter and another as a receiver. To support the wireless module the ESP32C3 was also connected to an antennae extension. The transmitter is wired to accept input from 3 switches, each button when pressed would toggle the associated pins on the receiver sides. The receiver is wired to 3 LEDs and when data is received from the transmitter, it would toggle the associated pins either from (HIGH to LOW) or (LOW to HIGH). The 3 LEDS, are just to indicate switching.\n","permalink":"http://localhost:1313/posts/hardware/","summary":"Hardware selection, Harware design","title":"Hardware Development Process"},{"content":"Flowchart Receiver Transmitter Discussion Technical challenges faced 1. No Arduino code requirement\nSince Arduino itself is a framework that relies on ESP IDF, the technical requirement of a codebase that does not use the Arduino framework is a major obstacle. ESP IDF in comparison is a low-level framework with a level of documentation and support that is orders of magnitude lower than that of Arduino.\n2. Lack of convenient APIs\nESP IDF also has a steeper learning curve as it comprises of low-level APIs specific to Espressif SoCs. Many functionalities will need to be written from scratch, compared to Arduino that enjoys an ecosystem of diverse libraries that make it easy to develop for.\n3. Limited Community Support\nOftentimes we are the first to implement something in pure ESP IDF. The technical documentation provided by ESP IDF is sometimes scarce, outdated, or available only in Chinese. Example implementations are often irrelevant, uncommented and supplied with no README.\nOvercoming the challenges We worked from afternoon to the early morning multiple times; reading through documentation and ESP IDF source code to debug our code. Since it seemed like an impossible requirement, we initially implemented our project using Arduino, and translated the code into pure ESP IDF once we figured out the base code.\n","permalink":"http://localhost:1313/posts/development_process/","summary":"Further discussion, technical challenges, and how we had overcome them","title":"Software development process"},{"content":"End product There are no words that best describe our promising project, so let us demonstrate our end product in action in the following video:\n(Youtube video here)\nApplications The Module serves as a very flexible attachment to any control systems that require switching. A receiver and transmitter are only required to establish the Intranet system. An example of application of the module would be in a relay circuit as the switch relay as shown below. The receiver would interact with the switch to enable the power of any high-powered system without being connected to the board and potentially frying it.\nOur Multipurpose IoT with RISC-V project can be implemented in endless scenarios, examples of application in the industry for this relay circuit would be::\nPublic Transport - Sexual harassment alarm, vehicle access, etc. Home Automation - Light control, security systems, etc. Industrial Application - Machine control, process monitoring, etc. Health Care - Patient room control, emergency systems, etc. Agriculture - Irrigation control, greenhouse automation, etc. Conclusion Our module is a proof-of-concept implementation of cloudless IoT technology. This paves the road towards Intranet of Things as opposed to Internet of Things. Our system operates independently of third-party vendors (such as AWS, Azure, Clouflare, etc.), ensuring complete vendor independence. The benefits of this approach make it an attractive option for organizations looking for secure IoT solutions, unlike the mainstream approach.\nThe primary advantage of our approach is full data sovereignty, allowing users to maintain full control over information and access.\nOur module is fully air-gapped, as no data is exchanged with external servers. This decreases the attack surface for malicious parties to exploit.\nBusinesses can achieve a higher degree of security and privacy while retaining complete ownership of their data.\nRecommendations ","permalink":"http://localhost:1313/posts/results/","summary":"See our end product in action, conclusion, and future recommendations","title":"Project Outcomes \u0026 Accomplishments"},{"content":"The source code for this web report is available here\r. Source code for the ESP32C3 boards are available here\r.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_system.h\u0026#34; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/timers.h\u0026#34; #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;esp_mac.h\u0026#34; #include \u0026#34;espnow_utils.h\u0026#34; #include \u0026#34;espnow.h\u0026#34; #include \u0026#34;espnow_ctrl.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;espnow_mem.h\u0026#34; // #include \u0026#34;build/config/sdkconfig.h\u0026#34; // Posuango popianai do intellisense nopo, pokinomio\u0026#39; pogulu mamaal /* Include only to shut up intellisense nagging */ #define KOTOS_1 2 // GPIO2, D0 id dulak / on the board #define KOTOS_2 3 // GPIO3, D1 id dulak / on the board #define KOTOS_3 4 // GPIO4, D2 id dulak / on the board int prev1 = 0; int prev2 = 0; int prev3 = 0; int current1 = 0; int current2 = 0; int current3 = 0; uint8_t pagatadan[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // Broadcast mode address static const char *TAG = \u0026#34;sodusuhu\u0026#34;; typedef struct gamit { int buttonstate1; int buttonstate2; int buttonstate3; int buttonstate4; int buttonstate5; int buttonstate6; } gamit; gamit dolinon; // Mamadalin do poiloon id pampos Poniasan / For transfering data to transmitter function static void ponimpuun_wifi() { esp_event_loop_create_default(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(\u0026amp;cfg)); ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM)); ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE)); ESP_ERROR_CHECK(esp_wifi_start()); } // Initialize read pins static void ponimpuun_pomiri(void) { gpio_reset_pin(KOTOS_1); gpio_reset_pin(KOTOS_2); gpio_reset_pin(KOTOS_3); /* Tolu GPIO hiti nopo nga\u0026#39; pinisok / Three of these GPIO are buttons */ gpio_set_direction(KOTOS_1, GPIO_MODE_INPUT); gpio_set_direction(KOTOS_2, GPIO_MODE_INPUT); gpio_set_direction(KOTOS_3, GPIO_MODE_INPUT); } // Function for reading GPIO pipns static void pomiri(void) { current1 = gpio_get_level(KOTOS_1); current2 = gpio_get_level(KOTOS_2); current3 = gpio_get_level(KOTOS_3); if (prev1 == 0 \u0026amp;\u0026amp; current1 == 1) { dolinon.buttonstate1 = 1; } else { dolinon.buttonstate1 = 0; } if (prev2 == 0 \u0026amp;\u0026amp; current2 == 1) { dolinon.buttonstate2 = 1; } else { dolinon.buttonstate2 = 0; } if (prev3 == 0 \u0026amp;\u0026amp; current3 == 1) { dolinon.buttonstate3 = 1; } else { dolinon.buttonstate3 = 0; } } static void poniasan(void *arg) { esp_err_t sinuli = ESP_OK; while (1) { pomiri(); vTaskDelay(50 / portTICK_PERIOD_MS); esp_now_send(pagatadan, (uint8_t *) \u0026amp;dolinon, sizeof(dolinon)); printf(\u0026#34;\\n%i\\n\u0026#34;, sinuli); printf(\u0026#34;Switch 1: %d\u0026#34;, dolinon.buttonstate1); printf(\u0026#34;Switch 2: %d\u0026#34;, dolinon.buttonstate2); printf(\u0026#34;Switch 3: %d\u0026#34;, dolinon.buttonstate3); prev1 = current1; prev2 = current2; prev3 = current3; vTaskDelay(100 / portTICK_PERIOD_MS); } ESP_LOGI(TAG, \u0026#34;Poniasan nakalabus / Transmission exited\u0026#34;); vTaskDelete(NULL); } static void ponimpuun_ponias(void) { xTaskCreate(poniasan, \u0026#34;Popotimpuun ponias / Initialize transmitter\u0026#34;, 4 * 1024, NULL, tskIDLE_PRIORITY + 1, NULL); } void app_main(void) { ponimpuun_pomiri(); espnow_storage_init(); ponimpuun_ponias(); ponimpuun_wifi(); espnow_config_t espnow_config = ESPNOW_INIT_CONFIG_DEFAULT(); espnow_init(\u0026amp;espnow_config); } ","permalink":"http://localhost:1313/posts/source_code/","summary":"View our code in detail","title":"Source code"}]